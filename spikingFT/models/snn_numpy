#!/usr/bin/env python3
"""
Module one-line definition
"""
# Standard libraries

# Local libraries


class FourierTransformSpikingNetworkTTFS():
    def __init__(self, n_input, n_chirps, **kwargs):
        """
        Initialize class
        """
        # Neuron properties
        self.v_threshold = 0.1
        # Network variables
        self.n_input = n_input
        self.n_chirps = n_chirps
        self.normalize = kwargs.get("normalize", True)
        self.spike_trains_l1 = np.zeros((self.n_input, 2*self.n_chirps))
        self.spike_trains_l2 = np.zeros((self.n_chirps, 2*self.n_input))

        # SNN simulation parameters
        self.time_step = kwargs.get("time_step", 0.001)
        self.sim_time = 0
        self.total_time = kwargs.get("total_time", 5)
        self.debug = kwargs.get("debug", False)

    def calculate_weights(self):
        self.weights = []
        self.__calculate_weights_layer1()
        self.__calculate_weights_layer2()

    def __calculate_weights_layer1(self):
        """
        Calculate 1-D FFT coefficients based on algorithm
        """
        # Constant present in all weight elements
        c_1 = 2*np.pi / self.n_input

        # Calculate the content of the cosines/sines as a dot product
        n = np.arange(self.n_input).reshape(self.n_input, 1)
        k1 = np.arange(self.n_input).reshape(1, self.n_input)
        trigonometric_factors = np.dot(n, k1) * c_1

        # Create the weights matrix for a single chirp
        real_weights = np.cos(trigonometric_factors)
        imag_weights = -np.sin(trigonometric_factors)

        # Normalize the weights by dividing by the input length. This is due to
        # the properties of the FFT
        if self.normalize:
            real_weights /= self.n_input
            imag_weights /= self.n_input

        # Create the final weights matrix by stacking the same matrix M times
        # where M is the number of chirps
        self.weights.append((real_weights, imag_weights))
        return self.weights

    def __calculate_weights_layer2(self):
        """
        Calculate 2-D FFT coefficients based on algorithm
        """
        # Constant present in all weight elements
        c_1 = 2*np.pi / self.n_chirps

        # Calculate the content of the cosines/sines as a dot product
        m = np.arange(self.n_chirps).reshape(self.n_chirps, 1)
        k2 = np.arange(self.n_chirps).reshape(1, self.n_chirps)
        trigonometric_factors = np.dot(m, k2) * c_1

        # Create the weights matrix for a single chirp
        cosine_factors = np.cos(trigonometric_factors)
        sine_factors = np.sin(trigonometric_factors)

        real_weights = -2*np.hstack((cosine_factors, sine_factors))
        imag_weights = -2*np.hstack((-sine_factors, cosine_factors))

        # Normalize the weights by dividing by the chirp length.
        if self.normalize:
            real_weights /= self.n_chirps
            imag_weights /= self.n_chirps

        # Create the final weights matrix by stacking the same matrix M times
        # where M is the number of chirps
        self.weights.append((real_weights, imag_weights))
        return self.weights

    def calculate_bias_layer2(self, offset=-1):
        """
        Set the bias value of all chirps to a constant
        """
        bias = np.zeros((self.n_chirps, 2*self.n_input))
        bias[0, :] = offset
        return bias

    def run(self, spike_trains, layers):
        """
        Main routine for running the simulation
        """
        logging.info("Running the TTFS Spiking-DFT")
        self.calculate_weights()
        layer_1 = SpikingNeuralLayer(
                                     (self.n_input, 2*self.n_chirps),
                                     self.weights[0],
                                     v_threshold=self.v_threshold,
                                     time_step=self.time_step
                                    )
        layer_2 = SpikingNeuralLayer(
                                     (self.n_chirps, 2*self.n_input),
                                     self.weights[1],
                                     v_threshold=self.v_threshold,
                                     time_step=self.time_step
                                    )
        causal_neurons_l1 = np.zeros(self.n_input)
        causal_neurons_l2 = np.zeros((self.n_input, 2*self.n_chirps))
        t_1, t_2, t_3, t_4, t_5 = 5*[0]
        rec_z1, rec_z6, rec_z8, rec_z14 = [], [], [], []

        logger.info("Layer 1: Charging stage")
        # Charging stage of layer 1
        while self.sim_time <= self.total_time:
            self.sim_time += self.time_step
            causal_neurons_l1 = (spike_trains < self.sim_time).reshape(
                    (self.n_chirps, self.n_input)
                )
            out_l1 = layer_1.update_state(causal_neurons_l1) * self.sim_time
            self.spike_trains_l1 += out_l1

        logger.info("Layer 1: Spiking stage - Layer 2: Charging stage")
        # Spiking stage of layer 1, and charging stage of layer 2
        layer_1.bias = 2 * self.v_threshold
        layer_2.bias = self.calculate_bias_layer2(0.25)
        input_spikes_l1 = np.zeros_like(causal_neurons_l1)
        while self.sim_time <= 2*self.total_time:
            self.sim_time += self.time_step
            relative_time = self.sim_time - self.total_time
            out_l1 = layer_1.update_state(input_spikes_l1)
            self.spike_trains_l1 += out_l1 * (relative_time)
            if layers == 1:
                continue
            ## Layer 2
            causal_neurons_l2 += out_l1
            out_l2 = layer_2.update_state(causal_neurons_l2)
            self.spike_trains_l2 += out_l2 * (relative_time)


        logger.info("Layer 2: Spiking stage")
        # Spiking stage of layer 2
        if layers == 2:
            layer_2.bias = 2 * self.v_threshold
            input_spikes_l2 = np.zeros_like(causal_neurons_l2)
            while self.sim_time <= 3*self.total_time:
                self.sim_time += self.time_step
                relative_time = self.sim_time - 2*self.total_time
                out_l2 = layer_2.update_state(input_spikes_l2)
                self.spike_trains_l2 += out_l2 * (relative_time)

        # All neurons that didn't spike are forced to spike in the last step,
        # since the spike-time of 1 corresponds to the lowest possible value.
        self.spike_trains_l1 += self.spike_trains_l1==0
        self.spike_trains_l1 = 1 - self.spike_trains_l1
        self.spike_trains_l2 += self.spike_trains_l2==0
        self.spike_trains_l2 = 1 - self.spike_trains_l2
        if layers == 1:
            return self.spike_trains_l1
        elif layers == 2:
            return self.spike_trains_l2


class SpikingNeuralLayer():
    """
    Class for implementing a single spiking-DFT neural layer

    Args:
        shape (int|list): number of neurons in the layer. Int for a 1D
            layer or an iterable of ints for N-D layers
        weights (np.array): Matrix containing the input weights to the
            layer. They have to be real numbers
        **bias (double): external current fed to the neurons
        **threshold (double): membrane voltage for generating a spike
        **time_step (double): time gap between iterations
    """
    def __init__(self, shape, weights, **kwargs):
        """
        Initialize the class
        """
        # Neuron properties
        self.bias = kwargs.get("bias", 0)
        self.v_threshold = kwargs.get("v_threshold", 0.05)
        # Neuron variables
        self.v_membrane = np.zeros(shape)
        self.spikes = np.zeros(shape)
        self.refactory = np.zeros(shape)
        self.weights = weights

        # Simulation parameters
        self.time_step = kwargs.get("time_step", 0.001)

    def update_input_currents(self, input_spikes):
        """
        Calculate the total current that circulates inside each neuron
        """
        # Calculate separately the currents to the real and imaginary neurons
        z_real = np.dot(self.weights[0], input_spikes.transpose())
        z_imag = np.dot(self.weights[1], input_spikes.transpose())
        z = np.hstack((z_real, z_imag))
        # Add bias to the result and multiply by time_step
        z += self.bias
        z *= self.time_step
        return z

    def update_membrane_potential(self, z):
        """
        Update membrane potential of each neuron

        The membrane potential increases based on the input current, and
        it returns to the rest voltage after a spike
        """
        self.v_membrane += z
        self.v_membrane *= (1-self.refactory)
        return self.v_membrane

    def generate_spikes(self):
        """
        Determine which neurons spike, based on membrane potential
        """
        # Generate a spike when the voltage is higher than the threshold
        self.spikes = np.where((self.v_membrane>self.v_threshold), True, False)
        # Activate the refactory period for the neurons that spike
        self.refactory += self.spikes
        return self.spikes

    def update_state(self, in_spikes):
        """
        Update internal state of neurons, based on input spikes
        """
        z = self.update_input_currents(in_spikes)
        self.update_membrane_potential(z)
        out_spikes = self.generate_spikes()
        return out_spikes


